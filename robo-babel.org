#+TITLE: Travis's Emacs Configuration
#+OPTIONS: toc:4 h:4

* Configuration
** About this file
<<babel-init>>

The next evolution in emacs config technology

Defaults from the beginning

#+begin_src emacs-lisp
;; default to better frame titles
(setq frame-title-format
      (concat  "%b - emacs@" (system-name)))

;; default to unified diffs
(setq diff-switches "-u")
#+end_src

** Emacs initialization
*** Package Setup

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/")t)
  
  ;; (add-to-list 'load-path (expand-file-name "c:/Users/trrogers/.emacs.d/elpa/emacs-eclim-20140125.258"))
  (add-to-list 'load-path "~/emacs/erc-highlight-nicknames")
  (add-to-list 'load-path "~/emacs/origami")
  (add-to-list 'load-path "~/emacs/ipa")
  (add-to-list 'load-path "~/emacs/httprepl")
  
  (package-initialize)
  
  ;; Requires
  (require 'use-package)
  (require 'bm)
  (require 'cl)
  (require 'cl-lib)                       
  (require 'discover)
  (require 'eclim)
  (require 'eclimd)
  (require 'company)
  (require 'company-emacs-eclim)
  (require 'dirtree)
  (require 'compile)
  (require 'highlight-symbol)
  (require 'visual-regexp-steroids)
  (require 'tls)
  (require 'erc)
  (require 'erc-highlight-nicknames)
  (require 'smart-mode-line)
  (require 'hungry-delete)
  (require 'google-this)
  (require 'clj-refactor)
  (require 'origami)
  (require 'ipa)
  (require 'rainbow-mode)
  (require 'rainbow-delimiters)
  (require 'httprepl)
  (require 'recentf)
#+end_src

Custom Variables

#+begin_src emacs-lisp
;; Custom Setup
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(custom-safe-themes (quote ("b21bf64c01dc3a34bc56fff9310d2382aa47ba6bc3e0f4a7f5af857cd03a7ef7" "fc5fcb6f1f1c1bc01305694c59a1a861b008c534cae8d0e48e4d5e81ad718bc6" "8f7e1668dd3a097964e6016c26d36822ab2e48fc3e9a3a2e2634224a5ca728c8" "1e194b1010c026b1401146e24a85e4b7c545276845fc38b8c4b371c8338172ad" "3a727bdc09a7a141e58925258b6e873c65ccf393b2240c51553098ca93957723" "756597b162f1be60a12dbd52bab71d40d6a2845a3e3c2584c6573ee9c332a66e" "6a37be365d1d95fad2f4d185e51928c789ef7a4ccf17e7ca13ad63a8bf5b922f" default)))
 '(eclim-eclipse-dirs (quote ("~/Downloads/eclipse")))
 '(eclim-executable "~/Downloads/eclipse/eclim")
 '(org-hide-leading-stars t))

(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
#+end_src

** General Configuration
*** Fringe
#+BEGIN_SRC emacs-lisp
  (when (window-system)
    (require 'git-gutter-fringe)
    (global-git-gutter-mode +1))

  (setq-default indicate-buffer-boundaries 'left)
  (setq-default indicate-empty-lines +1)
#+END_SRC
*** Visual Bookmarks

[[https://github.com/joodland/bm][Github page]]

#+begin_src emacs-lisp
  (setq bm-highlight-style 'bm-highlight-only-fringe)
  
  (global-set-key "\C-cbt" 'bm-toggle)
  (global-set-key "\C-cbn" 'bm-next)
  (global-set-key "\C-cbp" 'bm-previous)
  (global-set-key "\C-cba" 'bm-show-all)
#+end_src

*** File backup

#+begin_src emacs-lisp
;; Backup file settigs
(setq
 backup-directory-alist '(("." . "~/.saves"))
 delete-old-versions -1
 version-control t
 vc-make-backup-files t)
#+end_src

(add-to-list 'sml/replacer-regexp-list '("^~/development/" ":DEV:") t)

*** History

#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
'(kill-ring
  search-ring
  regexp-search-ring))
#+end_src
    
*** Window configuration

#+begin_src emacs-lisp
;; Modes
(tooltip-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(set-face-attribute 'default nil :height 110)
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+end_src

*** Winner mode - undo and redo window configuration

#+begin_src emacs-lisp
(winner-mode 1)
#+end_src

*** IDO mode - completion in many places
#+begin_src emacs-lisp
(ido-mode 1)
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
#+end_src

If you use imenu to look at the functions in a file, this will give you ido mode in that

#+begin_src emacs-lisp
  (defun ido-goto-symbol (&optional symbol-list)
        "Refresh imenu and jump to a place in the buffer using Ido."
        (interactive)
        (unless (featurep 'imenu)
          (require 'imenu nil t))
        (cond
         ((not symbol-list)
          (let ((ido-mode ido-mode)
                (ido-enable-flex-matching
                 (if (boundp 'ido-enable-flex-matching)
                     ido-enable-flex-matching t))
                name-and-pos symbol-names position)
            (unless ido-mode
              (ido-mode 1)
              (setq ido-enable-flex-matching t))
            (while (progn
                     (imenu--cleanup)
                     (setq imenu--index-alist nil)
                     (ido-goto-symbol (imenu--make-index-alist))
                     (setq selected-symbol
                           (ido-completing-read "Symbol? " symbol-names))
                     (string= (car imenu--rescan-item) selected-symbol)))
            (unless (and (boundp 'mark-active) mark-active)
              (push-mark nil t nil))
            (setq position (cdr (assoc selected-symbol name-and-pos)))
            (cond
             ((overlayp position)
              (goto-char (overlay-start position)))
             (t
              (goto-char position)))))
         ((listp symbol-list)
          (dolist (symbol symbol-list)
            (let (name position)
              (cond
               ((and (listp symbol) (imenu--subalist-p symbol))
                (ido-goto-symbol symbol))
               ((listp symbol)
                (setq name (car symbol))
                (setq position (cdr symbol)))
               ((stringp symbol)
                (setq name symbol)
                (setq position
                      (get-text-property 1 'org-imenu-marker symbol))))
              (unless (or (null position) (null name)
                          (string= (car imenu--rescan-item) name))
                (add-to-list 'symbol-names name)
                (add-to-list 'name-and-pos (cons name position))))))))
  
  
  (global-set-key (kbd "C-c g s") 'ido-goto-symbol)
#+end_src 

*** Mode line format

I use smart mode line, mostly for ease of use, someday ill customize

#+begin_src emacs-lisp
;; Smart mode line
(sml/setup)
(sml/apply-theme 'dark)
#+end_src

Minor modes I do not want to see

#+begin_src emacs-lisp
(require 'diminish)
(eval-after-load "google-this" '(diminish 'google-this-mode))
(eval-after-load "company" '(diminish 'company-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
(eval-after-load "smarparens" '(diminish 'smartparens-mode))
#+end_src

*** Change "yes or no" to "y or n"

I didnt even realize this was a thing, but its nice to have, if your lazy. Which I am.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Theme 

#+begin_src emacs-lisp
  (load-file "~/.emacs.d/themes/almost-monokai.el")
  (color-theme-almost-monokai)
  (set-face-foreground 'erc-input-face "lightblue")
#+end_src

*** Undo Tree mode - visualize your undos and branches

Use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain pointing

#+begin_src emacs-lisp
(use-package undo-tree
  :init
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+end_src

*** Eclim

#+begin_src emacs-lisp
(global-eclim-mode)
(company-emacs-eclim-setup)
(setq help-at-pt-display-when-idle t)
(setq help-at-pt-timer-delay 0.05)
(help-at-pt-set-timer)

;; Functions
(defun tr/exit-code-helper (cmd rx)
  "Pipe through perl looking for rx."
  (s-concat cmd
            "|perl -e 'my $flag=0; while(<>) { if ($_=~/" rx "/)"
            "{ $flag = 1 } print $_ } exit $flag'"))

(defvar tr/junit-failure-regex "(Failures: [1-9][0-9]*)|(Errors: [1-9][0-9]*)")

(defun tr/eclim-java-junit-all ()
  (interactive)
  (compile (tr/exit-code-helper
            (eclim--make-command (cons "java_junit" (eclim--expand-args '("-p"))))
            tr/junit-failure-regex)))

(defun tr/eclim-java-junit ()
  (interactive)
  (compile (tr/exit-code-helper
            (eclim--make-command (cons "java_junit" (eclim--expand-args '("-p" "-f" "-o"))))
            tr/junit-failure-regex)))


(add-to-list 'compilation-mode-font-lock-keywords
             '("Tests run: [0-9]*, Failures: [1-9][0-9]*,.*$"
               (0 compilation-error-face)))
(add-to-list 'compilation-mode-font-lock-keywords
             '("Tests run: [0-9]*, Failures: 0, Errors: [1-9][0-9]*,.*$"
               (0 compilation-error-face)))
(add-to-list 'compilation-mode-font-lock-keywords
             '("Tests run: [0-9]*, Failures: 0, Errors: 0, Time elapsed: .*$"
               (0 compilation-info-face)))

(defun tr/java-self-insert-complete (char)
  (lexical-let ((char char))
    (lambda ()
      (interactive)
      (insert char)
      (company-complete))))

(defun java-mode-keys ()
  (local-set-key (kbd "C-c o") 'eclim-java-import-organize)
  (local-set-key (kbd "C-c p") 'eclim-problems)
  (local-set-key (kbd "C-c P") 'eclim-problems-open)
  (local-set-key (kbd "C-c d") 'eclim-java-doc-comment)
  (local-set-key (kbd "C-c C-d") 'eclim-java-find-declaration)
  (local-set-key (kbd "C-c C-e") 'eclim-java-find-generic)
  (local-set-key (kbd "C-c C-r") 'eclim-java-find-references)
  (local-set-key (kbd "C-c C-t") 'eclim-java-find-type)
  (local-set-key (kbd "C-c C-f") 'eclim-java-format)
  (local-set-key (kbd "C-c G") 'eclim-java-generate-getter-and-setter)
  (local-set-key (kbd "C-c h") 'eclim-java-hierarchy)
  (local-set-key (kbd "C-c j") 'eclim-java-show-documentation-for-current-element)
  (local-set-key (kbd "C-c r") 'eclim-java-refactor-rename-symbol-at-point)
  (local-set-key (kbd "C-c s") 'eclim-java-method-signature-at-point)
  (local-set-key (kbd "C-c t") 'tr/eclim-java-junit)
  (local-set-key (kbd "C-c T") 'tr/eclim-java-junit-all)
  (local-set-key (kbd "C-c z") 'eclim-java-implement)
  (local-set-key (kbd ".") (tr/java-self-inserg-complete ".")))

(add-hook 'java-mode-hook 'java-mode-keys)
#+end_src
    
*** Company

#+begin_src emacs-lisp
(global-company-mode t)
#+end_src

*** Hungry delete

#+begin_src emacs-lisp
(global-hungry-delete-mode)
#+end_src

*** Google this

#+begin_src emacs-lisp
(google-this-mode 1)
#+end_src

*** Perl

#+begin_src emacs-lisp
;; Alias
(defalias 'perl-mode 'cperl-mode)
(setq cperl-invalid-face nil)
#+end_src

*** Endless toggle and launcher

Found these great global key bindings at endlessparentheses.com
Mnemonic example, "Emacs toggle column", C-x t c

#+begin_src emacs-lisp
  ;; Global keys
  (define-prefix-command 'endless/toggle-map)
  (define-key ctl-x-map "t" 'endless/toggle-map)
  
  (define-key endless/toggle-map "c" #'column-number-mode)
  (define-key endless/toggle-map "d" #'toggle-debug-on-error)
  (define-key endless/toggle-map "e" #'toggle-debug-on-error)
  (define-key endless/toggle-map "f" #'auto-fill-mode)
  (define-key endless/toggle-map "l" #'toggle-truncate-lines)
  (define-key endless/toggle-map "q" #'toggle-debug-on-quit)
  (define-key endless/toggle-map "t" #'endless/toggle-theme)
  ;;; Generalized version of `read-only-mode'.
  (define-key endless/toggle-map "r" #'dired-toggle-read-only)
  (autoload 'dired-toggle-read-only "dired" nil t)
  (define-key endless/toggle-map "w" #'whitespace-mode)
  
  ;; More from endless, say "Emacs launch calc", C-x l c
  (define-prefix-command 'launcher-map)
  ;; C-x l is `count-lines-page' by default. If you
  ;; use that, you can try s-l or <C-return>.
  (define-key ctl-x-map "l" 'launcher-map)
  (global-set-key (kbd "s-l") 'launcher-map)
  (define-key launcher-map "c" #'calc)
  (define-key launcher-map "d" #'ediff-buffers)
  (define-key launcher-map "f" #'find-dired)
  (define-key launcher-map "g" #'lgrep)
  (define-key launcher-map "G" #'rgrep)
  (define-key launcher-map "h" #'man) ; Help
  (define-key launcher-map "n" #'nethack)
  (define-key launcher-map "l" #'paradox-list-packages)
  (define-key launcher-map "s" #'eshell)
  (define-key launcher-map "t" #'proced) ; top
  
  (defmacro run (exec)
    "Return a function that runs the executable EXEC."
    (let ((func-name (intern (concat "endless/run-" exec))))
      `(progn
         (defun ,func-name ()
           ,(format "Run the %s executable." exec)
           (interactive)
           (start-process "" nil ,exec))
         ',func-name)))
  
  ;; (define-key launcher-map "v" (run "steam"))
  (define-key launcher-map "e" (run "eclipse"))
  (define-key launcher-map "p" (run "pidgin"))
  (define-key launcher-map "s" (run "spotify"))
  
  (defmacro browse (url)
    "Return a function that calls `browse-url' on URL."
    (let ((func-name (intern (concat "endless/browse-" url))))
      `(progn
         (defun ,func-name ()
           ,(format "Browse to the url %s." url)
           (interactive)
           (browse-url ,url))
         ',func-name)))
  
  (define-key launcher-map "r" (browse "http://www.reddit.com/r/emacs/"))
  (define-key launcher-map "w" (browse "http://www.emacswiki.org/"))
  (define-key launcher-map "?" (browse "http://emacs.stackexchange.com/"))
  (define-key launcher-map "a" (browse "http://www.penny-arcade.com/"))
  (define-key launcher-map "x" (browse "http://www.xkcd.com/"))
  (define-key launcher-map "m" (browse "http://www.gizmag.com/"))
  (define-key launcher-map "g" (browse "http://www.gmail.com/"))
#+end_src

*** Mastering Emacs Key Bindings

Some global bindings I found from mastering emacs blog

#+begin_src emacs-lisp
(global-set-key [f8] 'neotree-toggle)
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-ca" 'org-agenda)
(define-key global-map (kbd "RET") 'newline-and-indent)
#+end_src

Paradox is a better package manager, uses git hub as well so we need this token

#+begin_src emacs-listp
(setq paradox-github-token '0af38642de4c23e8399e7849d875a7118308f322)
#+end_src

*** Org

#+begin_src emacs-lisp
  (load-library "find-lisp")
  (setq org-agenda-files (find-lisp-find-files "~/org" "\.org$"))
  (setq org-default-notes-file "~/org/refile.org")
  (setq org-tags-column -100)
  
  (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/agenda.org" "Tasks")
         "* TODO %? %^G\n")
        ("n" "Note" entry (file+headline "~/org/agenda.org" "Notes")
         "* %?\n")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n %i")
        ("l" "Journal with link" entry (file+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n  %i\n  %a")))
  
  (setq org-todo-keywords
        '((sequence "TODO" "STARTED" "|" "DONE" "PUNT")))
  
  (setq org-todo-keyword-faces
        '(("TODO" . org-warning) ("STARTED" . "yellow")
          ("DONE" . "green") ("PUNT" . "purple")))
  
  (setq org-tag-alist '(("region" . ?r) ("sprint" . ?s) ("home" . ?h) ("adhoc" . ?a) ("project" . ?p) ("catexp" . ?c)))
  
  (setq org-log-done 'time)
  
  (setq org-agenda-custom-commands
             '(("h" "Agenda and Home-related tasks"
                ((tags-todo "home")
                 ))
               ("o" "Agenda and Office-related tasks"
                ((agenda "")
                 (tags-todo "sprint")
                 (tags-todo "project")
                 (tags-todo "catexp")
                 (tags-todo "region")
                 (tags-todo "adhoc")))))
  
  (add-hook 'org-mode-hook 'auto-fill-mode)
  
  (setq org-clock-into-drawer t)
#+end_src

*** Narrow-or-widen

#+begin_src emacs-lisp
(defun narrow-or-widen-dwim (p)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
Intelligently means: region, org-src-block, org-subtree, or defun,
whichever applies first.
Narrowing to org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is already
narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing command.
         ;; Remove this first conditional if you don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                (delete-other-windows))
               ((org-at-block-p)
                (org-narrow-to-block))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(define-key endless/toggle-map "n" #'narrow-or-widen-dwim)
;; This line actually replaces Emacs' entire narrowing keymap, that's
;; how much I like this command. Only copy it if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
#+end_src

*** Emphasize-buffer

First attempt at my own hand written customization, not just copied. Needs some work.

#+begin_src emacs-lisp
(fset 'emphasize-buffer
   "\C-u32\C-x}")
(global-set-key [f5] 'emphasize-buffer)
#+end_src

*** Windmove

#+begin_src emacs-lisp
(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings))
#+end_src

*** ERC

#+begin_src emacs-lisp
  (add-to-list 'erc-modules 'highlight-nicknames)
  (erc-update-modules)
  (erc-spelling-mode 1)
  (setq erc-autojoin-channels-alist '(("amazon.com" "#ingestion" "#recon")
                                      ("freenode.net" "#pfproject")))
  
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
  
  (defun start-amazon-irc ()
    "Connect to Amazon IRC."
    (interactive)
    (setq erc-autojoin-channels-alist '(("amazon.com" "#ingestion" "#recon" "#grcs")))
    (erc-tls :server "ircs.amazon.com" :port 6697
             :nick "trrogers" :full-name "trrogers"))
  
  (defun start-irc ()
    "Connect to IRC."
    (interactive)
    (setq erc-autojoin-channels-alist '(("freenode.net" "#pfproject")))
    (erc :server "irc.freenode.net" :port 6667 :nick "robochuck"))
  
  (add-hook 'erc-insert-post-hook
            (lambda () (goto-char (point-min))
              (when (re-search-forward
                     (regexp-quote (erc-current-nick)) nil t) (ding))))
  
  
#+end_src

Greg sent me this, is a way to have the mode line go very bright when erc is getting some action. Also provides a way
to mute that, which is very useful when a channel you dont care about is getting chatty

#+begin_src emacs-lisp
(defun gs/set-mode-line-background (color)
  (when color (set-face-background 'mode-line color)))

(lexical-let ((alerts '()))
  (defun gs/mode-line-alert (alert-id color)
    "Alert by setting the modeline to COLOR. If COLOR is the symbol
  clear then remove the current notification."
    (defun alerting-p (alert-id) (assoc alert-id alerts))
    (defun set-alerting (alert-id color)
      (when (not (alerting-p alert-id))
        (setq alerts (cons (cons alert-id color) alerts))
        (gs/set-mode-line-background color)))
    (defun remove-alert (alert-id) (setq alerts (assq-delete-all alert-id alerts)))
    (when (null alerts) (push (cons 'default (face-background 'mode-line)) alerts))
    (cond ((eq alert-id 'print) alerts)
          ((eq color 'clear)
           (when (alerting-p alert-id)
             (progn (remove-alert alert-id)
                    (gs/set-mode-line-background (cdar alerts)))))
          ((alerting-p alert-id) nil)
          (t (set-alerting alert-id color)))))

(defvar gs/erc-notify-mute-buffers nil
  "Buffers that are currently muted and should not be alerted if
activity occurs.")

(defun gs/erc-toggle-mute-buffer ()
  (interactive)
  (if (memq (current-buffer) gs/erc-notify-mute-buffers)
      (progn (setq gs/erc-notify-mute-buffers (delete (current-buffer)
                                                      gs/erc-notify-mute-buffers))
             (message "Buffer unmuted"))
    (add-to-list 'gs/erc-notify-mute-buffers (current-buffer))
    (message "Buffer muted")))

(defun gs/erc-notify-activity ()
  (if (not (null erc-modified-channels-alist))
      (when (not (every (lambda (channel)
                          (memq (car channel) gs/erc-notify-mute-buffers))
                        erc-modified-channels-alist))
        (gs/mode-line-alert 'erc-notify "#00ff00"))
    (gs/mode-line-alert 'erc-notify 'clear)))

(add-hook 'erc-track-list-changed-hook 'gs/erc-notify-activity)
#+end_src

*** Clojure Refactor
**** Commands
Combine with the prefix, C-c C-f

th: thread another expression
uw: unwind a threaded expression
ua: fully unwind a threaded expression
tf: wrap in thread-first (->) and fully thread
tl: wrap in thread-last (->>) and fully thread
il: introduce let
el: expand let
ml: move to let
rf: rename file, update ns-declaration, and then query-replace new ns in project.
ar: add require to namespace declaration, then jump back (see optional setup)
au: add "use" (ie require refer all) to namespace declaration, then jump back
ai: add import to namespace declaration, then jump back
ru: replace all :use in namespace with :refer :all
sn: sort :use, :require and :import in the ns form
rr: remove unused requires
pc: run project cleaner functions on the whole project
sr: stop referring (removes :refer [] from current require, fixing references)
cc: cycle surrounding collection type
cp: cycle privacy of defns and defs
cs: cycle between "string" -> :string -> "string"
ci: refactoring between if and if-not
ad: add declaration for current top-level form
dk: destructure keys
mf: move one or more forms to another namespace, :refer any functions
sp: Sort all dependency vectors in project.clj
rd: Remove (debug) function invocations depends on refactor-nrepl
ap: add a dependency to your project depends on refactor-nrepl

#+begin_src emacs-lisp
;; CLJ Refactor
(add-hook 'clojure-mode-hook
	  (lambda()
	    (clj-refactor-mode 1)
	    (paredit-mode 1)
	    (cljr-add-keybindings-with-prefix "C-c C-f")
	    ))
#+end_src

*** Auto Fill Mode

#+begin_src emacs-lisp
(setq-default fill-column 120)
#+end_src

*** Origami
This is gregs folding code, works pretty well, this is just the key chords I am using

#+begin_src emacs-lisp
  (key-chord-define-global "o[" 'origami-open-node-recursively)
  (key-chord-define-global "c]" 'origami-close-node)
  (key-chord-define-global "[]" 'origami-show-only-node)
#+end_src

*** IPA

In Place Annotations, lets you make annotations on a file without modifying the original file.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c i i") 'ipa-insert)
  (global-set-key (kbd "C-c i e") 'ipa-edit)
  (global-set-key (kbd "C-c i t") 'ipa-toggle)
  (global-set-key (kbd "C-c i s") 'ipa-show)
  (global-set-key (kbd "C-c i n") 'ipa-next)
  (global-set-key (kbd "C-c i p") 'ipa-previous)
#+end_src

*** Guide-Key

Popup for key shortcuts

#+begin_src emacs-lisp
(use-package guide-key
  :init
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1))  
#+end_src

*** Rainbow Delimiters

#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

*** Buffer Mangement

Function from Greg, used to quickly create new scratch buffers

#+BEGIN_SRC emacs-lisp
  (defun gs/create-new-scratch-buffer ()
    "This creates a new *scratch* buffer regardless of whether one
  exists. It then switches to it."
    (interactive)
    (let ((buf (generate-new-buffer "*scratch*")))
      (switch-to-buffer buf)
      (lisp-interaction-mode)))
  
  (global-set-key (kbd "C-c b b") 'gs/create-new-scratch-buffer)
#+END_SRC

*** RecentF

Find a file from a list of your most recent files. Very handy because i look at the same files over and over and over
again all the time.

#+BEGIN_SRC emacs-lisp
  ;; get rid of `find-file-read-only' and replace it with something
  ;; more useful.
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
  
  ;; enable recent files mode.
  (recentf-mode t)
  
  ; 50 files ought to be enough.
  (setq recentf-max-saved-items 50)
  
  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
  
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)

  (setq projectile-enable-caching t)

#+END_SRC

** Navigation
*** Pop to mark

Hande way of getting back to previous places

#+begin_src emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+end_src

*** Better window splitting

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury

#+begin_src emacs-lisp
  (defun travis/vsplit-last-buffer (_)
    "Split the window vertically and display the previous buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (switch-to-next-buffer))
  (defun travis/hsplit-last-buffer (_)
    "Split the window horizontally and display the previous buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (switch-to-next-buffer))
  (bind-key "C-x 2" 'travis/vsplit-last-buffer)
  (bind-key "C-x 3" 'travis/hsplit-last-buffer)
#+end_src

*** Key-chord

#+begin_src emacs-lisp
(key-chord-mode 1)
;; faster shift
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "7u" "&")
(key-chord-define-global "8i" "*")
(key-chord-define-global "9o" "(")
(key-chord-define-global "0p" ")")
;; Ace jump
(key-chord-define-global "aj" 'ace-jump-mode)
;; Magit
(key-chord-define-global "jk" 'magit-status)

(key-chord-define-global "uu" 'undo)
#+end_src
